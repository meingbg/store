#!/bin/bash

function list-dir {
init-repo
cat "$repo"/list|grep -E "$1"
}

function init-repo {
mkdir -p "$repo"/tmp
touch "$repo"/list
}

function hashsum {
sha1sum|sed -r 's/^([^ ]*).*$/\1/'
}

function save-dir {
init-repo
statfile="`tmpfile`"
dirname="`basename "$1"`"
dirhash="`dir-to-repo "$1" 2>"$statfile"`"
date="`date +%Y%m%d%H%M`"
commithash_sd="`(echo d$date;echo c$dirhash;create-commit-stat "$statfile"|sed -r 's/^/s/')|content-to-hash 2>/dev/null`"
saveline="${dirname}_${date}_$commithash_sd"
if [ "`grep -Fc "$saveline" "$repo"/list`" -eq "0" ]
then echo "$saveline" >> "$repo"/list
fi
rm "$statfile"
echo ""
get-commit-stat "$saveline"
echo ""
return
}

function get-commit-stat {
init-repo
commit="`select-commit "$1"`"
if [ "${commit}" == "" ]; then return; fi
commithash_gcs="`echo "$commit"|sed -r 's/^.*_([^_]*)$/\1/'`"
echo "Snapshot name: $commit"
hash-to-content "$commithash_gcs"|sed -r 's/^d/Date saved: /;s/^c/Directory hash: /;s/^s//'
}

function intsum {
cat|sed -r 's/^[^0-9]*([0-9]+)[^0-9]*$/\1+/'|(echo 0;cat;echo p)|dc
}

function create-commit-stat {
echo "Bytes: `cat "$1"|grep -F -- --bytes-a|intsum`"
echo "Files: `cat "$1"|grep -F -- --files|intsum`"
echo "Directories: `cat "$1"|grep -F -- --directories|intsum`"
echo "Symlinks: `cat "$1"|grep -F -- --symlinks|intsum`"
echo "Nodes: `cat "$1"|grep -F -- --nodes|intsum`"
echo "Bytes after deduplication: `cat "$1"|grep -F -- --bytes-d|intsum`"
echo "Bytes after compression: `cat "$1"|grep -F -- --bytes-c|intsum`"
}

function dir-to-repo {
(
dn="`dir-wo-slash "$1"`"
echo n"`basename "$dn"`"
atime_dtr="`ls -ldu --full-time "$dn"|sed -r 's/^[^ ]+\ +[0-9]+\ +[^ ]+\ +[^ ]+\ +[0-9]+\ +([0-9-]+\ [0-9:.]+\ [0-9+-]+).*$/\1/'`"
settings-from-file "$dn"|sed -r 's/^/s/'
(dir-content-to-repo "$dn"|sed -r 's/^/c/')
touch -ad "$atime_dtr" "$dn"
echo --directories 1 >&2;
)|content-to-hash
}

function dir-content-to-repo {
ls -1A "$1"|
(while IFS="" read a_dctr; do
if [ -h "$1"/"$a_dctr" ]; then echo l"`symlink-to-repo "$1"/"$a_dctr"`"
else
if [ -d "$1"/"$a_dctr" ]; then echo d"`dir-to-repo "$1"/"$a_dctr"`"; fi
if [ -f "$1"/"$a_dctr" ]; then echo f"`file-to-repo "$1"/"$a_dctr"`"; fi
fi
done
)|sort
}

function dir-wo-slash {
echo "$1"|sed -r 's/\/$//'
}

function file-size {
ls -ld "$1"|sed -r 's/^[^ ]+\ +[0-9]+\ +[^ ]+\ +[^ ]+\ +([0-9]+)\ .*$/\1/'
}

function content-to-hash {
tf_cth="`tmpfile`"; tfgz="`tmpfile`"
cat > "$tf_cth"
h="`cat "$tf_cth"|hashsum`"
h1="`echo "$h"|sed -r 's/^(..).*$/\1/'`"
h2="`echo "$h"|sed -r 's/^..//'`"
if [ -f "$repo"/$h1/$h2 -o -f "$repo"/$h1/$h2.gz ];
then rm "$tf_cth"; rm "$tfgz"
else mkdir -p "$repo"/$h1
cat "$tf_cth"|gzip>"$tfgz"
echo --nodes 1 >&2
echo --bytes-d "`file-size "$tf_cth"`" >&2
if [ "`file-size "$tfgz"`" -lt "`file-size "$tf_cth"`" ]
then echo --bytes-c "`file-size "$tfgz"`" >&2; mv "$tfgz" "$repo"/$h1/$h2.gz;rm "$tf_cth"
else echo --bytes-c "`file-size "$tf_cth"`" >&2; mv "$tf_cth" "$repo"/$h1/$h2;rm "$tfgz"
fi
fi
echo "$h1$h2"
}

function file-to-repo {
(
echo n"`basename "$1"`"
atime_ftr="`ls -ldu --full-time "$1"|sed -r 's/^[^ ]+\ +[0-9]+\ +[^ ]+\ +[^ ]+\ +[0-9]+\ +([0-9-]+\ [0-9:.]+\ [0-9+-]+).*$/\1/'`"
settings-from-file "$1"|sed -r 's/^/s/'
h="`cat "$1"|hashsum`"
h1="`echo "$h"|sed -r 's/^(..).*$/\1/'`"
h2="`echo "$h"|sed -r 's/^..//'`"
echo --files 1 >&2;
echo --bytes-a "`file-size "$1"`" >&2; 
if [ -f "$repo"/$h1/$h2.cat -o -f "$repo"/$h1/$h2.gz -o -f "$repo"/$h1/$h2 ]; then echo c$h1$h2; else echo c"`cat "$1"|content-to-hash`"; fi
)|content-to-hash
touch -ad "$atime_ftr" "$1"
}

function symlink-to-repo {
(
echo n"`basename "$1"`"
echo l"`readlink "$1"`"
settings-from-file "$1"|sed -r 's/^/s/'
echo --symlinks 1 >&2;
echo --bytes-a "`file-size "$1"`" >&2; 
)|content-to-hash
}

function select-commit {
if [ "`cat "$repo"/list|grep -Fc "$1"`" -gt "1" ];
then echor "More than one snapshot matches:" >&2
cat "$repo"/list|grep -F "$1" 1>&2
return
fi
if [ "`cat "$repo"/list|grep -Fc "$1"`" -eq "0" ];
then echor "No directory matches." >&2
return
fi
cat "$repo"/list|grep -F "$1"
}

function load-dir {
init-repo
commithash_ld="`select-commit "$1"|sed -r 's/^.*_([^_]*)$/\1/'`"
if [ "${commithash_ld}" == "" ]; then exit; fi
dirhash="`hash-to-content "$commithash_ld"|grep -E '^c'|sed -r 's/^.//'`"
dir-from-repo "$dirhash" "`dir-wo-slash "$2"`"
}

function dir-from-repo {
tf_dfr="`hash-to-content "$1"`"
name="`echo "$tf_dfr"|grep -E '^n'|sed -r 's/^.//'`"
ndir="$2"/"$name"
mkdir "$ndir"
echo "$tf_dfr"|grep -E '^c'|sed -r 's/^.//'| dir-content-from-repo "$ndir"
echo "$tf_dfr"|grep -E '^s'|sed -r 's/^.//'| settings-to-file "$ndir"
}

function dir-content-from-repo {
while IFS="" read a_dcfr; do
class="`echo "$a_dcfr"|sed -r 's/^(.).*$/\1/'`"
hash_dcfr="`echo "$a_dcfr"|sed -r 's/^.//'`"
if [ "$class" == "d" ]; then dir-from-repo "$hash_dcfr" "$1"; fi
if [ "$class" == "f" ]; then file-from-repo "$hash_dcfr" "$1"; fi
if [ "$class" == "l" ]; then symlink-from-repo "$hash_dcfr" "$1"; fi
done
}

function hash-to-content {
h1="`echo "$1"|sed -r 's/^(..).*$/\1/'`"
h2="`echo "$1"|sed -r 's/^..([^ ]*).*$/\1/'`"
if [ -f "$repo"/$h1/$h2.cat ]
then cat "$repo"/$h1/$h2.cat|
(while IFS="" read a_htc; do hash-to-content "$a_htc" ;done)
else
if [ -f "$repo"/$h1/$h2.gz ]
then cat "$repo"/$h1/$h2.gz|gunzip
else
if [ -f "$repo"/$h1/$h2 ]
then cat "$repo"/$h1/$h2
fi
fi
fi
}

function file-from-repo {
tfs="`hash-to-content "$1"`"
name="`echo "$tfs"|grep -E '^n'|sed -r 's/^.//'`"
nfile="$2"/"$name"
hash-to-content "`echo "$tfs"|grep -E '^c'|sed -r 's/^.//'`" > "$nfile"
echo "$tfs"|grep -E '^s'|sed -r 's/^.//'| settings-to-file "$nfile"
}

function symlink-from-repo {
name="`hash-to-content "$1"|grep -E '^n'|sed -r 's/^.//'`"
link="`hash-to-content "$1"|grep -E '^l'|sed -r 's/^.//'`"
ln -s "$link" "$2"/"$name"
hash-to-content "$1"|grep -E '^s'|sed -r 's/^.//'| settings-to-file "$2"/"$name"
}

function settings-from-file {
lsld="`ls -ld --full-time "$1"`"
echo o"`echo "$lsld"|sed -r 's/^[^ ]+\ +[0-9]+\ +([^ ]+).*$/\1/'`"
echo g"`echo "$lsld"|sed -r 's/^[^ ]+\ +[0-9]+\ +[^ ]+\ +([^ ]+).*$/\1/'`"
echo m"`echo "$lsld"|sed -r 's/^[^ ]+\ +[0-9]+\ +[^ ]+\ +[^ ]+\ +[0-9]+\ +([0-9-]+\ [0-9:.]+\ [0-9+-]+).*$/\1/'`"
echo a"`ls -ldu --full-time "$1"|sed -r 's/^[^ ]+\ +[0-9]+\ +[^ ]+\ +[^ ]+\ +[0-9]+\ +([0-9-]+\ [0-9:.]+\ [0-9+-]+).*$/\1/'`"
echo p"`echo "$lsld"|sed -r 's/^.(.........).*$/\1/'`"
}

function settings-to-file {
while IFS="" read a; do
attribute="`echo "$a"|sed -r 's/^(.).*$/\1/'`"
value="`echo "$a"|sed -r 's/^.//'`"
if [ "$attribute" == "o" ]; then chown -h "$value" "$1"; fi
if [ "$attribute" == "g" ]; then chgrp -h "$value" "$1"; fi
#no support for symlink modification/access times or permissions.
if [ ! -h "$1" ]; then
if [ "$attribute" == "m" ]; then touch -md "$value" "$1"; fi
if [ "$attribute" == "a" ]; then touch -ad "$value" "$1"; fi
if [ "$attribute" == "p" ]; then perm-to-file "$value" "$1"; fi
fi
done
}

function perm-to-file {
chmod "`echo "$1"|sed -r 's/--x/1/g;s/-w-/2/g;s/-wx/3/g;s/r--/4/g;s/r-x/5/g;s/rw-/6/g;s/rwx/7/g;s/---/0/g;'`" "$2"
}

function tmpfile {
tempfile -d "$repo"/tmp
}

function echor {
echo -ne '\e[31m'
echo "$@"
echo -ne '\e[0m'
}

function echog {
echo -ne '\e[32m'
echo "$@"
echo -ne '\e[0m'
}

function hash-to-filename {
if [ "$1" == "-" ]; then echo "$repo"/list; else
h1="`echo "$1"|sed -r 's/^(..).*$/\1/'`"
h2="`echo "$1"|sed -r 's/^..([^ ]*).*$/\1/'`"
if [ -f "$repo"/$h1/$h2.cat ]
then echo "$repo"/$h1/$h2.cat
else
if [ -f "$repo"/$h1/$h2.gz ]
then echo "$repo"/$h1/$h2.gz
else
if [ -f "$repo"/$h1/$h2 ]
then echo "$repo"/$h1/$h2
fi
fi
fi
fi
}

function nodes-existing {
ls -1A "$repo"|grep -E '^[0-9a-f]{2}$'|(while IFS="" read a; do ls -1A "$repo/$a"|sed -r 's/^/'"$a"'/';done)|sed -r 's/\.gz$//;s/\.cat$//'|grep -Ev '\.delete$'|sort
}

function files-existing {
ls -1A "$repo"|grep -E '^[0-9a-f]{2}$'|(while IFS="" read a; do ls -1A "$repo/$a"|(while IFS="" read b; do echo "$repo/$a/$b"; done);done)|sort
}

function nodes-referenced {
echo "$1"
type="`echo "$1"|sed -r 's/^(.).*$/\1/'`"

if [ ! "$type" == "-" ];then
hash_nr="`echo "$1"|sed -r 's/^.//'`"
path="`hash-to-filename "$hash_nr"`"
if [ ! -f "$path" ]; then return; fi
if [ "`echo "$path"|grep -Ec '\.cat$'`" == "1" ]
    then cat "$path"|(while IFS="" read a_nr; do nodes-referenced b"$a_nr"; done)
fi
if [ "$type" == "b" ]; then return; fi
fi
if [ "$type" == "-" ]
then cat "$repo"/list
else hash-to-content "$hash_nr"
fi|
case "$type" in
    "-")
            sed -r 's/^.*_([^_]*)$/c\1/';;
    "c")
            grep -E '^c'|sed -r 's/^c/d/';;
    "d")
            grep -E '^c'|sed -r 's/^c//';;
    "f")
            grep -E '^c'|sed -r 's/^c/b/';;
    "l")
            grep -E '^c'|sed -r 's/^c/b/';;
esac|(while IFS="" read a_nr; do nodes-referenced "$a_nr"; done)
}

function all-nodes-referenced {
nodes-referenced -|grep -Fv '-'|sed -r 's/^.//'|sort|uniq
}

function all-files-referenced {
nodes-referenced -|grep -Fv '-'|sed -r 's/^.//'|sort|uniq|
(while IFS="" read a_afr; do
echo "`hash-to-filename "$a_afr"`"
done)|sort
}

function missing-nodes {
diff <(all-nodes-referenced) <(nodes-existing)|grep -E '^<'|sed -r 's/^< //'
}

function files-for-gc {
diff <(files-existing) <(all-files-referenced)|grep -E '^<'|sed -r 's/^< //'
}

function check-sum-errors {
nodes-existing|
(while IFS="" read hash_cse; do
checksum="`hash-to-content "$hash_cse"|hashsum`"
if [ ! "$checksum" == "$hash_cse" ]; then echo "$hash_cse $checksum";fi
done)
}

function check-sum {
check-sum-errors|sed -r 's/^(.*)\ (.*)$/Node \1 has unmatching checksum \2/'
}

function node-integrity {
type="`echo "$1"|sed -r 's/^(.).*$/\1/'`"

if [ "$type" == "-" ]
then cat "$repo"/list
else
hash_ni="`echo "$1"|sed -r 's/^.//'`"
path="`hash-to-filename "$hash_ni"`"
if [ ! -f "$path" ]; then return; fi
#if [ "`echo "$path"|grep -Ec "\.cat"`" == "1" ]; then cat "$path"|sed -r 's/^/b/';fi #exit on nonexisting?
if [ "$type" == "b" ]; then return; fi
hash-to-content "$hash_ni"
fi|
case "$type" in
    "-")
            grep -Ecv '^.*_[0-9]{12}_[0-9a-f]{40}$';;
    "c")
            grep -Ecv '^s[A-Z][a-z ]*\:\ [0-9]+$|^d[0-9]{12}$|^c[0-9a-f]{40}$';;
    "d")
            grep -Ecv '^n.+|^sp[rwx-]{9}$|^s[og].+|s[ma][0-9 :.+-]+$|^c[dfl][0-9a-f]{40}$';;
    "f")
            grep -Ecv '^n.+|^sp[rwx-]{9}$|^s[og].+|s[ma][0-9 :.+-]+$|^c[0-9a-f]{40}$';;
    "l")
            grep -Ecv '^n.+|^l[0-9a-f]{40}$';;
esac
#fixme: some line prefixes does not allow multiple lines, need to check this.
}

function all-nodes-integrity {
nodes-referenced -|sort|uniq|
(while IFS="" read a_ani; do if [ "0`node-integrity "$a_ani"`" -gt "0" ]; then echo "$a_ani";fi;done)|
sed -r 's/^(.)/\1 /;s/^f /File /;s/^d /Directory /;s/^l /Link /;s/^c /Snapshot /;s/^-.*$/list/;s/^(.*)$/\1 is corrupt/'
}

function integrity {
itf="`tmpfile`"
echog "Checking repository integrity..." >&2
(
echog "   Checking format integrity..." >&2
all-nodes-integrity
echog "   Computing checksums..." >&2
check-sum
echog "   Looking for missing nodes..." >&2
missing-nodes|sed -r 's/^(.*)$/Node \1 is missing/'
)|tee "$itf"
if [ "`grep -c "" "$itf"`" -eq "0" ];
then echog "No corruption detected" >&2
return 0
else return 1
fi
rm "$itf"
}

function gc {
tf_gc="`tmpfile`"
echog "Computing cleanup..."
files-for-gc>"$tf_gc"
if [ "`grep -c "" "$tf_gc"`" -eq "0" ];
then echog "No files to delete"
else
if [ "$1" == "listonly" ]
then echog "The following files can be deleted:"; cat "$tf_gc"
else echog "Marking files for deletion..."
     cat "$tf_gc"|(while IFS="" read a; do
     echo mv "$a" "$a".delete; mv "$a" "$a".delete ;done)
     if integrity
     then echog "Deleting files..."
         cat "$tf_gc"|(while IFS="" read a; do
         echo rm "$a".delete; rm "$a".delete ;done)
     else echor "Corruption detected, unmarking all files..."
         cat "$tf_gc"|(while IFS="" read a; do
         echo mv "$a".delete "$a"; mv "$a".delete "$a" ;done)
         echor "You might want to check the repository integrity"
     fi
fi
fi
rm "$tf_gc"
}

function gc-list {
gc listonly
}

function file-part {

let hl="$3"-"$2"
if [ "$hl" -lt 1028 ]
then dd if="$1" bs=1 count="$hl" skip="$2" 2>/dev/null
else

let tsp="$2"/1024*1024
if [ ! "$tsp" -eq "$2" ]
then let tsp="$tsp"+1024
     (file-part "$1" "$2" "$tsp")
     (file-part "$1" "$tsp" "$3")
else

let tep="$3"/1024*1024
if [ ! "$tep" -eq "$3" ]
then (file-part "$1" "$2" "$tep")
     (file-part "$1" "$tep" "$3")
else

let tsp="$2"/1024
let tep="$3"/1024
let hl="$tep"-"$tsp"
dd if="$1" bs=1024 count="$hl" skip="$tsp" 2>/dev/null
fi;fi;fi
}

function hash-from-file-part {
file-part "$1" "$2" "$3"|hashsum
}

function common-prefixl-of {
f1="$1"
f2="$2"
ep="`file-size "$f1"`"
l2="`file-size "$f2"`"
if [ "$l2" -lt "$ep" ]; then ep="$l2";fi
bp="0"
while [ "$bp" -lt "$ep" ]; do
let np=("$ep"-"$bp")/2+"$bp"
if [ "$np" == "$bp" ]; then nbp="$ep"; else nbp="$np";fi
if [ "`hash-from-file-part "$f1" "$bp" "$nbp"`" == "`hash-from-file-part "$f2" "$bp" "$nbp"`" ]; then bp="$nbp"; else ep="$np";fi
done
echo "$bp"
}

function dedup-prefix {
cf1="`tmpfile`";hash-to-content "$1" > "$cf1"
cf2="`tmpfile`";hash-to-content "$2" > "$cf2"
cpl="`common-prefixl-of "$cf1" "$cf2"`"
nf1="`tmpfile`";file-part "$cf1" 0 "$cpl" > "$nf1"
nf2="`tmpfile`";file-part "$cf1" "$cpl" "`file-size "$cf1"`" > "$nf2"
nf3="`tmpfile`";file-part "$cf2" "$cpl" "`file-size "$cf2"`" > "$nf3"
make-cat "$nf1" "$nf2"
make-cat "$nf1" "$nf3"
rm "$cf1" "$cf2" "$nf1" "$nf2" "$nf3"
}

function make-cat {
if [ "`file-size "$1"`" -eq 0 -o "`file-size "$2"`" -eq 0 ]; then return;fi
nch="`cat "$1" "$2"|hashsum`"
ncf="$repo/`echo "$nch"|sed -r 's/^(..)/\1\//'`.cat"
(cat "$1"|content-to-hash;cat "$2"|content-to-hash)>"$ncf" 2>/dev/null
echo "$nch"
cat "$ncf"
echog "Substituting $nch for the concatenation of" >&2
cat "$ncf"|sed -r 's/^/     /' >&2
echo "     (`file-size "$1"` and `file-size "$2"` bytes respectively)" >&2
}

function update-prefix-index {
while IFS="" read h_upi; do
if [ "`hash-to-filename "$h_upi"|grep -Ec '\.cat$'`" == "1" ]
then tf_upi="`tmpfile`"
     cat "$1"|grep -Fv " $h_upi">"$tf_upi"
     mv "$tf_upi" "$1"
else
prefh="`hash-to-content "$h_upi"|dd count=1 bs=$prefixl 2>/dev/null|hashsum`"
if [ ! "$prefh" == "$h_upi" ]; then echo "$prefh $h_upi" >> "$1";fi
fi
done
tf_upi="`tmpfile`";cat "$1"|sort|uniq>"$tf_upi";mv "$tf_upi" "$1"
}

function deduplicate {
prefixl=5242880
echog "Deduplicating file prefixes (minimum length $prefixl bytes)..."
dtf="`tmpfile`";dtf2="`tmpfile`"
nodes-existing|update-prefix-index "$dtf"
while [ ! "$dtfh" == "`cat "$dtf"|hashsum`" ]; do
dtfh="`cat "$dtf"|hashsum`"
cp "$dtf" "$dtf2"
dih2="";dip2="";cat "$dtf2"|(while read dip dih; do
if [ "$dip" == "$dip2" ]; then dedup-prefix "$dih" "$dih2";fi
dih2="$dih";dip2="$dip"
done)|update-prefix-index "$dtf"
done
rm "$dtf" "$dtf2"
echog "Compiling concatenation files..."
cat-compile
echog "Done. You might want to perform a garbage collect now."
}

function cat-compile {
#backup .cat-files and check integrity before finishing.
ctf="`tmpfile`"
ctfn="`tmpfile`"
ls -1A "$repo"|grep -E '^[0-9a-f]{2}$'|(while IFS="" read a; do ls -1A "$repo/$a"|(while IFS="" read b; do echo "$repo/$a/$b"; done);done)|grep -E '\.cat$'|sort|uniq>"$ctf"
while [ "`file-size "$ctf"`" -gt "0" ]; do
cat "$ctf"|(while IFS="" read a_cc; do cat-compile-file "$a_cc"; done)>"$ctfn"
mv "$ctfn" "$ctf"
done
rm "$ctf"
}

function cat-compile-file {
f="$1"
tf_ccf="`tmpfile`"
cat "$f"|(while IFS="" read a_ccf; do
path="`hash-to-filename "$a_ccf"`"
if [ "`echo "$path"|grep -Ec '\.cat$'`" == "1" ]
then cat "`hash-to-filename "$a_ccf"`"
else echo "$a_ccf"
fi; done)>"$tf_ccf"
if [ ! "`cat "$tf_ccf"|hashsum`" == "`cat "$f"|hashsum`" ]
then echo "$1"; mv "$tf_ccf" "$f"
else rm "$tf_ccf"
fi
}

function usagehelp {
echo ""
echo Usage:
c="`if [ ! "$(whoami)" == "root" ]; then echo "sudo "; fi`""$0"
echo "$c" "save dir [repo]        -- save a snapshot of directory dir"
echo "$c" "load snap todir [repo] -- extract snapshot snap to directory todir"
echo "$c" "list [pattern] [repo]  -- list the snapshots matching pattern"
echo "$c" "stat snap [repo]       -- show information about snapshot snap"
echo "$c" "deduplicate [repo]     -- perform prefix deduplication to use even less diskspace"
echo "$c" "gc [repo]              -- garbage collect a repository (delete unused files)"
echo "$c" "gc-list [repo]         -- show what files are not needed"
echo "$c" "integrity [repo]       -- perform a data integrity check"
echo "$c" "                       -- see this help"
echo ""
echo "repo is the path to the repository to operate on."
echo "repo defaults to [current working directory]/repo"
echo ""
}

if [ ! "`whoami`" == "root" ]; then usagehelp; exit; fi

if [ "$1" == "save" ];
then dir="$2"; repo="$3"
if [ "$repo" == "" ]; then repo="repo"; fi
if [ ! -d "$dir" ]; then echo "Directory does not exist"; exit; fi
save-dir "$dir"
exit
fi

if [ "$1" == "list" ];
then pattern="$2" repo="$3"
if [ "$repo" == "" ]; then repo="repo"; fi
list-dir "$pattern"
exit
fi

if [ "$1" == "load" ];
then dir="$2"; todir="$3"; repo="$4"
if [ "$repo" == "" ]; then repo="repo"; fi
if [ ! -d "$todir" ]; then echo "Target directory does not exist"; exit; fi
load-dir "$dir" "$todir"
exit
fi

if [ "$1" == "stat" ];
then commit_stat="$2"; repo="$3"
if [ "$repo" == "" ]; then repo="repo"; fi
get-commit-stat "$commit_stat"
exit
fi

if [ "$1" == "deduplicate" -o "$1" == "gc" -o "$1" == "gc-list" -o "$1" == "integrity" ];
then repo="$2"
if [ "$repo" == "" ]; then repo="repo"; fi
$1
exit
fi

#debugging
if [ "$1" == "do" ]
then repo="repo"; $2
exit
fi

usagehelp
